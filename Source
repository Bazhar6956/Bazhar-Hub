-- Made By Bazhar#6956


local ScreenGui = Instance.new("ScreenGui")
local UI = Instance.new("ScreenGui")
local UI_2 = Instance.new("Frame")
local BackGround = Instance.new("Frame")
local Container = Instance.new("Frame")
local Padding = Instance.new("UIPadding")
local Hitbox = Instance.new("TextButton")
local Esp = Instance.new("TextButton")
local UnderLine = Instance.new("Frame")
local Toggle = Instance.new("TextButton")
local Window = Instance.new("TextLabel")


ScreenGui.Parent = game.CoreGui

UI.Name = "UI"
UI.Parent = ScreenGui
UI.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

UI_2.Name = "UI"
UI_2.Parent = UI
UI_2.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
UI_2.BorderSizePixel = 0
UI_2.Position = UDim2.new(0, 15, 0, 15)
UI_2.Size = UDim2.new(0, 190, 0, 30)

BackGround.Name = "BackGround"
BackGround.Parent = UI_2
BackGround.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
BackGround.BorderColor3 = Color3.fromRGB(27, 42, 53)
BackGround.BorderSizePixel = 0
BackGround.Position = UDim2.new(0, 0, 1, 0)
BackGround.Size = UDim2.new(0, 190, 0, 200)

Container.Name = "Container"
Container.Parent = UI_2
Container.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
Container.BorderColor3 = Color3.fromRGB(27, 42, 53)
Container.BorderSizePixel = 0
Container.Position = UDim2.new(0, 0, 0.966666639, 0)
Container.Size = UDim2.new(0, 190, 0, 200)

Padding.Name = "Padding"
Padding.Parent = Container
Padding.PaddingLeft = UDim.new(0, 10)
Padding.PaddingTop = UDim.new(0, 5)

Hitbox.Name = "Hitbox"
Hitbox.Parent = Container
Hitbox.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
Hitbox.BorderColor3 = Color3.fromRGB(85, 255, 127)
Hitbox.Position = UDim2.new(0.0412649028, 0, 0.153677091, 0)
Hitbox.Size = UDim2.new(0, 163, 0, 21)
Hitbox.Font = Enum.Font.SourceSans
Hitbox.Text = "Hitbox"
Hitbox.TextColor3 = Color3.fromRGB(85, 255, 127)
Hitbox.TextSize = 14.000

Esp.Name = "Esp"
Esp.Parent = Container
Esp.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
Esp.BorderColor3 = Color3.fromRGB(85, 255, 127)
Esp.Position = UDim2.new(0.0294795483, 0, 0.387975097, 0)
Esp.Size = UDim2.new(0, 163, 0, 21)
Esp.Font = Enum.Font.SourceSans
Esp.Text = "Esp"
Esp.TextColor3 = Color3.fromRGB(85, 255, 127)
Esp.TextSize = 14.000

UnderLine.Name = "UnderLine"
UnderLine.Parent = UI_2
UnderLine.BackgroundColor3 = Color3.fromRGB(85, 255, 127)
UnderLine.BorderSizePixel = 0
UnderLine.Position = UDim2.new(0, 0, 1, -1)
UnderLine.Size = UDim2.new(1, 0, 0, 1)

Toggle.Name = "Toggle"
Toggle.Parent = UI_2
Toggle.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Toggle.BackgroundTransparency = 1.000
Toggle.Position = UDim2.new(1, -25, 0, 0)
Toggle.Size = UDim2.new(0, 25, 1, 0)
Toggle.Font = Enum.Font.SourceSans
Toggle.Text = "-"
Toggle.TextColor3 = Color3.fromRGB(85, 255, 127)
Toggle.TextSize = 17.000

Window.Name = "Window"
Window.Parent = UI_2
Window.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Window.BackgroundTransparency = 1.000
Window.Size = UDim2.new(1, 0, 1, 0)
Window.Font = Enum.Font.SourceSans
Window.Text = "Bazhar Hub "
Window.TextColor3 = Color3.fromRGB(85, 255, 127)
Window.TextSize = 17.000

-- Scripts:

local function EHSNPYD_fake_script() -- Hitbox.Hitbox Script 
	local script = Instance.new('LocalScript', Hitbox)

	script.Parent.MouseButton1Click:Connect(function()
		_G.Size = 20 --Change to any size 100> Or else you will lag
		while true do
			for i,v in next, game:GetService('Players'):GetPlayers() do 
				if v ~= plr then 
					pcall(function()
						v.Character.HDetector.Size = Vector3.new(_G.Size, _G.Size, _G.Size, _G.Size) --Any size it's bypassed now
						v.Character.HDetector.Transparency=0.65
						v.Character.HDetector.Color = Color3.fromHSV(0.3745, 0.666667, 1)
						v.Character.HDetector.Massless = true--Really ez just makes it massless obv
					end)
				end
			end
			wait()
		end
	end)
end
coroutine.wrap(EHSNPYD_fake_script)()
local function NXVPWG_fake_script() -- Esp.Esp script 
	local script = Instance.new('LocalScript', Esp)

	script.Parent.MouseButton1Click:Connect(function()
		local VEC3 = Vector3.new
		local VEC2 = Vector2.new
		local COL3 = Color3.new
		local RGB = Color3.fromRGB
		local CFNEW = CFrame.new
		local INSTNEW = Instance.new
		local TBLINS = table.insert
		local Drawing_new = Drawing.new
		local Ray_new = Ray.new
		local TweenInfo_new = TweenInfo.new
	
		local Players = game:GetService("Players")
		local Workspace = game:GetService("Workspace")
		local RunService = game:GetService("RunService")
		local UserInputService = game:GetService("UserInputService")
		local TweenService = game:GetService("TweenService")
		local Camera = Workspace:FindFirstChildOfClass("Camera")
	
		local LocalPlayer = Players.LocalPlayer
		local Mouse = LocalPlayer:GetMouse()
	
		_G.PlayerLocation = function()
		--[[
		-- GLOBAL ESP
		local Humanoids = {}
		for i,v in pairs(Workspace:GetDescendants()) do
			if v:IsA("Humanoid") or v.Name == "Humanoid" then
				TBLINS(Humanoids, v.Parent)
			end
		end
		return Humanoids;
		]]--
			return Players:GetChildren();
		end
	
		CreateDrawing = function(ClassName)
			return function(Props)
				local Create = Drawing_new(ClassName)
				for i,v in pairs(Props) do
					Create[i] = v
				end
				return Create
			end
		end;
	
		local Drawings = {}
		function IsPartVisible(Part1, Part2)
			local CheckPart = INSTNEW("Part")
			CheckPart.Parent = Workspace
			CheckPart.Name = "CheckVisWall"
			CheckPart.Anchored = true
			CheckPart.CanCollide = false
			CheckPart.Transparency = 1
			CheckPart.Size = VEC3(1.5, 1.5, 1.5) * Part2.Size
			CheckPart.CFrame = Part2.CFrame
	
			local Ray = Ray_new(Part1.Position, (Part2.Position - Part1.Position).Unit * 9999)
			local part,position = workspace:FindPartOnRay(Ray, Part1.Parent)
			if part then
				if part.Name == CheckPart.Name then
					CheckPart:Destroy()
					return true
				end
			end
			CheckPart:Destroy()
			return false
		end
	
		function GetLookVectorAndOrigin(PART)
			local Origin = PART.CFrame
			local LookVector = PART.CFrame.lookVector * 100
			--local Direction = (LookVector - Origin.p).Unit * 100
	
			--local Ray = Ray.new(Origin.p, Direction)
			--local _, EndPosition = workspace:FindPartOnRay(Ray)
	
			return {
				Origin = Origin;
				EndPoint = LookVector;--Workspace:Raycast(Origin, Direction.p).Position;
			}
		end
		function Get8Corners(PART, OFF)
			if not OFF then OFF = VEC3(1, 1, 1) end
			local CornerVertices = {
				{1, 1, -1},  --v1 - top front right
				{1, -1, -1}, --v2 - bottom front right
				{-1, -1, -1},--v3 - bottom front left
				{-1, 1, -1}, --v4 - top front left
	
				{1, 1, 1},  --v5 - top back right
				{1, -1, 1}, --v6 - bottom back right
				{-1, -1, 1},--v7 - bottom back left
				{-1, 1, 1}  --v8 - top back left
			}
			local Vertices = {}
			local Size = PART.Size * OFF
			for _, Vector in pairs(CornerVertices) do
				TBLINS(Vertices, (PART.CFrame * CFNEW(Size .X/2 * Vector[1], Size .Y/2 * Vector[2], Size .Z/2 * Vector[3])).Position)
			end
			return Vertices
		end
	
		function tocam(pos)
			local PosChar, withinScreenBounds = Camera:WorldToViewportPoint(pos)
			return {VEC2(PosChar.X, PosChar.Y), withinScreenBounds}
		end
		function GetPropPC(inst, prop)
			local func, result = pcall(function()
				return inst[prop]
			end)
			if not func then
				return nil 
			else 
				return result 
			end
		end
		function Cleanup()
			for i,v in pairs(Drawings) do
				v:Remove()
				--table.remove(Drawings, i)
			end
			Drawings = {}
		end
		function Create3DVertex(PART, SETT)
			local VertexPositions = Get8Corners(PART, SETT.Offset)
			for i,v in pairs(Get8Corners(PART, VEC3(0.01, 0.01, 0.01))) do
				if not tocam(v)[2] then return end
			end
			local Thickness = SETT.Thickness
			local Transparency = SETT.Transparency
			local Visible = SETT.Visible
			local Color = SETT.Color
			local Filled = SETT.Filled
			local Positions = {
				{
					tocam(VertexPositions[5])[1];
					tocam(VertexPositions[6])[1];
					tocam(VertexPositions[2])[1];
					tocam(VertexPositions[1])[1];
				};
				{
					tocam(VertexPositions[7])[1];
					tocam(VertexPositions[8])[1];
					tocam(VertexPositions[4])[1];
					tocam(VertexPositions[3])[1];
				};
				{
					tocam(VertexPositions[1])[1];
					tocam(VertexPositions[2])[1];
					tocam(VertexPositions[3])[1];
					tocam(VertexPositions[4])[1];
				};
				{
					tocam(VertexPositions[5])[1];
					tocam(VertexPositions[6])[1];
					tocam(VertexPositions[7])[1];
					tocam(VertexPositions[8])[1];
				};
			}
	
			for i = 1,#Positions do
				local NewVertex = CreateDrawing("Quad") {
					["Visible"] = Visible;
					["Transparency"] = Transparency;
					["Thickness"] = Thickness;
					["Color"] = Color;
					["Filled"] = Filled;
					["PointA"] = Positions[i][1];
					["PointB"] = Positions[i][2];
					["PointC"] = Positions[i][3];
					["PointD"] = Positions[i][4];
				}
				Drawings[#Drawings + 1] = NewVertex
			end
		end
	
	
		--[[ Initialize ESP ]]--
		spawn(function()
			while true do
				Cleanup()
	
				local func, ok = pcall(function()
					for i,v in pairs(_G.PlayerLocation()) do
						if v.Name ~= LocalPlayer.Name then
							local Char = GetPropPC(v, "Character") or v or nil
							local TeamCheck = (GetPropPC(v, "Team") ~= LocalPlayer.Team) or (GetPropPC(v, "TeamColor") ~= LocalPlayer.TeamColor) or (LocalPlayer.Team == nil)
							if Char and TeamCheck then
								local Root = Char:FindFirstChild("HumanoidRootPart") or nil
								local Head = Char:FindFirstChild("Head") or nil
	
								if Root and Head and tocam(Head.Position)[2] then
									--[[ Vertex ]]--
									Create3DVertex(Root, {
										["Offset"] = VEC3(2.25, 3, 3);
										["Thickness"] = 1;
										["Transparency"] = 1;
										["Filled"] = false;
										["Visible"] = true;
										["Color"] = COL3(85, 255, 0);
									}) 
	
									--[[ Health ]]--
									Create3DVertex(Root, {
										["Offset"] = VEC3(2.25, 3/100*Char.Humanoid.Health, 3);
										["Thickness"] = 1;
										["Transparency"] = 0.1;
										["Filled"] = true;
										["Visible"] = true;
										["Color"] = COL3(85, 255, 0);
									})
	
									--[[ Tracer ]]--
									local ToCam = tocam(Head.Position)
									if ToCam[2] then
										local Mag = (LocalPlayer.Character.Head.Position - Head.Position).Magnitude
										local NewLine = CreateDrawing("Line") {
											["Visible"] = true;
											["Transparency"] = 1;
											["Thickness"] = 1;
											["Color"] = RGB(85, 255, 0);
											["From"] = VEC2(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y * 0.80);
											["To"] = ToCam[1];
										}
										Drawings[#Drawings + 1] = NewLine
									end
	
									--[[ OverHead ]]--
	
									--[[ IsVisible ]]--
									local Color = COL3(85, 255, 0);
									for i,v in pairs(Char:GetChildren()) do
										if v:IsA("BasePart") then
											if IsPartVisible(LocalPlayer.Character.Head, v) then
												Color = COL3(85, 255, 0);
											end
										end
									end
									local PosPart = INSTNEW("Part")
									PosPart.CFrame = Head.CFrame
									PosPart.Size = VEC3(1,1,1)
									PosPart.Transparency = 1
									Create3DVertex(PosPart, {
										["Offset"] = VEC3(1,1,1);
										["Thickness"] = 1;
										["Transparency"] = 1;
										["Filled"] = false;
										["Visible"] = true;
										["Color"] = Color;
									})
									PosPart:Destroy()
								end
							end
						end
					end
					return true
				end)
				if not func then warn(ok) end
	
				RunService.RenderStepped:Wait()
			end
		end)
	end)
end
coroutine.wrap(NXVPWG_fake_script)()
local function JEYGV_fake_script() -- Toggle.LocalScript 
	local script = Instance.new('LocalScript', Toggle)

	local back = script.Parent.Parent.BackGround
	local con = script.Parent.Parent.Container
	
	local window = {
			count = 0;
			toggles = {},
			closed = false;
		}
		script.Parent.MouseButton1Click:connect(function()
			window.closed = not window.closed
			script.Parent.Text = (window.closed and "+" or "-")
			if script.Parent.Text == "+" then
				back:TweenSize(UDim2.new(0, 190,0, 0), "Out", "Sine", 0.5)
				con:TweenSize(UDim2.new(0, 190,0, 0), "Out", "Sine", 0.5)
				wait(0.1) do
				con.Visible = false
				end
			else
				back:TweenSize(UDim2.new(0, 190,0, 200), "Out", "Sine", 0.5)
				con:TweenSize(UDim2.new(0, 190,0, 200), "Out", "Sine", 0.5)
				wait(0.2) do
				con.Visible = true
				end
				end
			
		end)
	
end
coroutine.wrap(JEYGV_fake_script)()
local function YWVWOE_fake_script() -- UI_2.LocalScript 
	local script = Instance.new('LocalScript', UI_2)

	local dragger = {}; 
	local resizer = {};
	
	do
		local mouse = game:GetService("Players").LocalPlayer:GetMouse();
		local inputService = game:GetService('UserInputService');
		local heartbeat = game:GetService("RunService").Heartbeat;
		-- // credits to Ririchi / Inori for this cute drag function :)
		function dragger.new(frame)
		    local s, event = pcall(function()
		    	return frame.MouseEnter
		    end)
	
		    if s then
		    	frame.Active = true;
	
		    	event:connect(function()
		    		local input = frame.InputBegan:connect(function(key)
		    			if key.UserInputType == Enum.UserInputType.MouseButton1 then
		    				local objectPosition = Vector2.new(mouse.X - frame.AbsolutePosition.X, mouse.Y - frame.AbsolutePosition.Y);
		    				while heartbeat:wait() and inputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) do
		    					frame:TweenPosition(UDim2.new(0, mouse.X - objectPosition.X + (frame.Size.X.Offset * frame.AnchorPoint.X), 0, mouse.Y - objectPosition.Y + (frame.Size.Y.Offset * frame.AnchorPoint.Y)), 'Out', 'Quad', 0.1, true);
		    				end
		    			end
		    		end)
	
		    		local leave;
		    		leave = frame.MouseLeave:connect(function()
		    			input:disconnect();
		    			leave:disconnect();
		    		end)
		    	end)
		    end
		end
		
		function resizer.new(p, s)
			p:GetPropertyChangedSignal('AbsoluteSize'):connect(function()
				s.Size = UDim2.new(s.Size.X.Scale, s.Size.X.Offset, s.Size.Y.Scale, p.AbsoluteSize.Y);
			end)
		end
	end
	script.Parent.Active = true
	script.Parent.Draggable = true
end
coroutine.wrap(YWVWOE_fake_script)()
